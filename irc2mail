#!/usr/bin/perl -w

# Sun Jun  9 15:17:28 CEST 2013
(my $email='chrjae%gmail,com')=~ tr/%,/@./;

use strict;
use Carp::Always;

our $logdir= "$ENV{HOME}/.xchat2/xchatlogs";
our $maxage= 120; # seconds before mail is sent

$0=~ /(.*?)([^\/]+)\z/s or die "?";
my ($mydir, $myname)=($1,$2);
sub usage {
    print STDERR map{"$_\n"} @_ if @_;
    print "$myname path/to/config.pl

  config.pl must return a hashtable mapping nicknames to a map with
  key 'to' mapping to an email address.
  i.e.  { <nick> => { to=> <to> }}

  $myname observes all xchat style irc log files under '$logdir', and
  sends mail to <to> if <nick> appears in new messages (with nick
  appended or prepended with underscores also matching). Note that
  nick is case sensitively matched.

  Queues messages until the first is $maxage seconds old, then sends
  them grouped by channel; or drops them all if <nick> says something
  anywhere [todo: treat /me messages as saying, too]

  (Christian Jaeger <$email>)
";
exit (@_ ? 1 : 0);
}

use Getopt::Long;
our $verbose=0;
our $opt_dry;
GetOptions("verbose"=> \$verbose,
	   "help"=> sub{usage},
	   "dry-run"=> \$opt_dry,
	   ) or exit 1;
usage unless @ARGV==1;

our ($configpath)=@ARGV;

our $from= $ENV{EMAIL}
  or die "need EMAIL env var to be set";

use lib "/opt/chj/perllib";
use Chj::xopen 'xopen_read';
use Chj::xperlfunc;
use Chj::xopendir;
use Fcntl 'SEEK_END';
use Chj::Sendmail 'sendmail';
use Chj::load;

our $config= require $configpath;

sub Log {
    print STDERR time," ", @_, "\n"
}

sub debug {
    if ($verbose) {
	Log "DEBUG: ", @_
    }
}

sub xprintln { print @_, "\n" or die $! };

sub send_notification ($$$) {
    my ($nick, $channel, $msgs)=@_;
    print STDERR time."  sending notification for '$nick', channel '$channel'\n";
    my $mailto= $$config{$nick}{to};
    if ($opt_dry) {
	xprintln "-- to $mailto, channel $channel ----";
	for (@$msgs) {
	    xprintln " ", $_
	}
	xprintln;
    } else {
	sendmail(From=> $from,
		 To=> $mailto,
		 Subject=> "[$myname] $channel",
		 Data=> join("",map{"$_\n"}@$msgs))
    }
}



sub _Message { debug "new _Message, @_";
	       bless +{@_},'_Message' }
# channel, text
{
    package _Message;
}

sub _Queue { debug "new _Queue, @_";
	     bless +{@_},'_Queue' }
# starttime, q
{
    package _Queue;
    sub do_add {
	my $s=shift;
	push @{$$s{q}},@_;
    }
    sub by_channel {
	my $s=shift;
	my %channel;
	for my $msg (@{$$s{q}}) {
	    push @{ $channel{$$msg{channel}} }, $$msg{text}
	}
	\%channel
    }
}

# queue ----

our %nick2queue;

sub enqueue_notification ($ $) {
    my ($nick,$msg)=@_;
    my $queue= $nick2queue{$nick} || _Queue (starttime=> time);
    $queue->do_add ($msg);
    $nick2queue{$nick}= $queue;
}

sub queue_checksend () {
    for my $nick (keys %nick2queue) {
	my $queue= $nick2queue{$nick};
	my $age= time - $$queue{starttime};
	if ($age > $maxage) {
	    debug "send out queue";
	    my $by_channel= $queue->by_channel;
	    for my $channel (keys %$by_channel) {
		my $msgs= $$by_channel{$channel};
		send_notification ($nick, $channel, $msgs)
	    }
	    delete $nick2queue{$nick};
	}
    }
}

sub delete_queue ($) {
    my ($nick)=@_;
    debug "delete_queue ('$nick')"
      if delete $nick2queue{$nick};
}

# parsing ----

our $whore= qr/<([^<>]+)>\s*(.*)/;

sub linematches {
    my ($line)=@_;
    if (my ($who,$rest)= $line=~ /$whore/) {
	my @res;
	for my $nick (keys %$config) {
	    my $nickre= qr/\b[_]*$nick[_]*\b/;
	    if ($who=~ /^$nickre$/) {
		#debug "ignore self-said";
		delete_queue ($nick);
	    } else {
		push @res, $nick
		  if $rest=~ /$nickre/;
	    }
	}
	#debug "linematchP '$line' = ".Dumper($res);
	@res	
    } else {
	()
    }
}

sub scanfd {
    my ($f,$channel)=@_;
    while (<$f>) {
	my $line=$_;
	chomp $line;
	my $msg= _Message (channel=> $channel, text=> $line);
	for my $nick (linematches $line) {
	    my $maybe_channels= $$config{$nick}{channels};
	    if (! $maybe_channels or $$maybe_channels{$channel}) {
		enqueue_notification ($nick, $msg);
	    } else {
		Log "ignoring mentioning of '$nick' on channel '$channel'";
	    }
	}
    }
}

our %path2fd;

my %ignored;
sub do_replenishfds {
    my ($scan_appearances)=@_;
    my $d= xopendir $logdir;
    while (defined (my$item= $d->xnread)) {
	if ($item=~ /^(.+)\.log\z/) {
	    my $channel=$1;
	    if (not exists $path2fd{$item}) {
		debug "open '$item'";
		my $f= xopen_read "$logdir/$item";
		if ($scan_appearances) {
		    #debug "scanfd";
		    scanfd ($f,$channel);
		} else {
		    #debug "xseek";
		    $f->xseek(0,SEEK_END);
		}
		$path2fd{$item}=$f;
	    }
	} else {
	    unless ($ignored{$item}) {
		Log "ignoring item '$item'";
		$ignored{$item}=1;
	    }
	}
    }
}

do_replenishfds (0);

while (1) {
    sleep 2;
    # ^ still needs to be small (smaller than the attention period
    # after writing something, i.e. can't be just $maxage), because
    # the scanning doesn't currently get the time of the last outbound
    # message, nor does it prevent/undo queuing of newer messages from
    # previously scanned log files.
    for my $item (keys %path2fd) {
	scanfd ($path2fd{$item},$item);
    }
    do_replenishfds (1);
    queue_checksend ();
}

#use Chj::ruse;
#use Chj::Backtrace; use Chj::repl; repl;
